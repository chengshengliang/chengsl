(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{159:function(e,s,t){"use strict";t.r(s);var n=t(0),a=Object(n.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("js模块化很好解决了js文件之间依赖的问题，他将一大堆js和功能块细分成细小的功能块，\n使得代码维护性和可读性大大的提升")]),e._v(" "),t("h2",{attrs:{id:"commonjs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#commonjs"}},[e._v("#")]),e._v(" commonjs")]),e._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[e._v("    介绍：commonjs规范主要用于server端的模块化规范，他是同步加载的，而且是在运行时候加载，\n    有缓存的，CommonJS模块的加载机制是，引入值是抛出值的拷贝。\n    也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。\n\n    使用：commonjs用法是使用modeule"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("exports向外抛出接口，require引入其他模块使用。\n    也可以使用exports暴漏变量或者函数，他其实就是指向module"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("exports"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("commonjs不能直接被浏览器识别，\n    需要通过browerfy编译为浏览器可以直接识别的语法\n\n    commonjs是如何加载模块的？\n    require命令是CommonJS规范之中，用来加载其他模块的命令。它其实不是一个全局命令，\n    而是指向当前模块的module"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("require命令，而后者又调用Node的内部命令Module"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("_load\n    在module"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("load下，有几个执行步骤，\n    "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),e._v("：判断缓存中是否有指定模块，如果有，取缓存\n    "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),e._v("：无的话创建一个新的modeul实例，\n    "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("3")]),e._v("：将他存入缓存中"),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("4")]),e._v("：执行modeule"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("load加载指定模块内容\n    "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("5")]),e._v("：内容加载后，再通过module"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("compiler执行文件代码，\n    "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("6")]),e._v("：如果加载和编译过程出现错误，则会从缓存中删除该模块，反之则返回该模块的module"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("exports\n    \n\n")])])]),t("h2",{attrs:{id:"es6module"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6module"}},[e._v("#")]),e._v(" es6module")]),e._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[e._v("    \n    使用：es6模块是目前应用最广泛的模块化之一，他也是需要通过babel编译成es5语法，\n    commonjs，再通过browerfy编译为浏览器可以直接识别的语法。\n    他模块向外是通过"),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("export")]),e._v(" 和"),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("import")]),e._v("引入，es6则是在编译时候加载的，是异步加载模块，\n    他是一个对值的引用，模块内部值发生变化时候外部值也会响应发生变化。\n    当浏览器的js引擎静态分析时候，识别到了"),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("import")]),e._v("命令，就会生成一个只读引用。\n    等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。\n\n")])])]),t("h2",{attrs:{id:"amd"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#amd"}},[e._v("#")]),e._v(" Amd")]),e._v(" "),t("p",[e._v("requirejs是amd规范的产物，首先，他是依赖前置，需要将需要加载依赖提前加载好，无论你要不要用，通过define定义，return暴漏出去，通过require引用，通过回调函数形式执行其他代码，")]),e._v(" "),t("h2",{attrs:{id:"cmd"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cmd"}},[e._v("#")]),e._v(" cmd")]),e._v(" "),t("p",[e._v("seajs则是阿里团队研究出来的，结合commonjs和requirejs的规范，使用上和require很相似，暴漏则是通过commonjs规范，define定义通过回调内的参数require，module，export执行，他对于依赖模块，则是就近原则，需要用到时候require进来使用即可")]),e._v(" "),t("p",[e._v("参考文档\n"),t("a",{attrs:{href:"https://juejin.im/post/5c82323ce51d453a5f22b281#heading-12",target:"_blank",rel:"noopener noreferrer"}},[e._v("掘金上对于模块化的分析"),t("OutboundLink")],1),e._v(" "),t("a",{attrs:{href:"https://juejin.im/entry/56cebad0c4c971c376dfd0fc",target:"_blank",rel:"noopener noreferrer"}},[e._v("掘金上对于模块化的分析"),t("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=a.exports}}]);