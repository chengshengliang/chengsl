(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{141:function(s,t,e){s.exports=e.p+"assets/img/webpack1.cb24cf9f.png"},142:function(s,t,e){s.exports=e.p+"assets/img/webpack-plugin.c434544a.png"},143:function(s,t,e){s.exports=e.p+"assets/img/webpack-watch.daa50c96.png"},144:function(s,t,e){s.exports=e.p+"assets/img/webpack-hot.c8fbfb1d.png"},145:function(s,t,e){s.exports=e.p+"assets/img/webpack-hash.13a8ecf7.png"},146:function(s,t,e){s.exports=e.p+"assets/img/sourceMap.fc822daa.png"},164:function(s,t,e){"use strict";e.r(t);var a=e(0),n=Object(a.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"对webpack基础认识"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对webpack基础认识"}},[s._v("#")]),s._v(" 对webpack基础认识")]),s._v(" "),a("p",[a("img",{attrs:{src:e(141),alt:"基础结构"}})]),s._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[s._v("webpack：图片介绍了webpack几个基础结构，其中原生webpack只能解析js和json文件，loader作用就是为了webpack可以解析更多文件类型如css，sass，图片，字体等\n插件plugins则是丰富了webpack功能在整个构建过程中，做了loader无法完成的事情\n\n")])])]),a("p",[a("img",{attrs:{src:e(142),alt:"常见插件"}})]),s._v(" "),a("p",[s._v("自动构建原理如下图所示：\n"),a("img",{attrs:{src:e(143),alt:"自动构建原理"}})]),s._v(" "),a("p",[s._v("热更新原理如下图所示：\n"),a("img",{attrs:{src:e(144),alt:"热更新原理"}}),s._v("\n热更新过程\n1：启动阶段：文件系统里面，文件系统进行编译，初始的代码经过webpack Compiler进行打包，打包编译好之后，把编译好文件传给bundle server（其实就是一个服务器，可以以server方式让浏览器访问文件）\n2：文件更新阶段：文件变化时候，这时候文件系统变化后代码通过webpack Compiler进行打包，将编译好的代码发送给hmr server ，hmr server就知道哪些模块（源代码）发生了改变，改变之后hmr server（服务端）会通知hmr runtime（开发打包阶段，通过打包编译阶段注入到bundlejs里面存在于浏览器端，从而浏览器就可以和服务器建立一个websocket连接），总而言之就是hmrserver知道哪些变化以json形式数据传输给到hmrruntime，这时候hmr runtime就会更新代码，这时候代码就会改变，并且不需要手动刷新浏览器。")]),s._v(" "),a("p",[s._v("hash种类如下图所示：\n"),a("img",{attrs:{src:e(145),alt:"hash种类"}})]),s._v(" "),a("p",[s._v("开发或者打包后如何排查问题？通过以下source-map：\n"),a("img",{attrs:{src:e(146),alt:"hash种类"}})]),s._v(" "),a("p",[s._v("treeshaking原理和使用\n页面引入很多方法，整个文件都会打包到bundle文件去，\n而引入treeshaking则会把有引用到的文件打包，其他去除")]),s._v(" "),a("p",[s._v("何种代码才会被treeshaking：1：代码不会执行或者没执行到，2：或者执行结果不会被用到，：代码只写不读，")]),s._v(" "),a("p",[s._v("必须要使用es6语法时候才会生效且编写代码不能有副作用，否则treeshaking会失效。\n原理：利用es6模块的原理，es6引入导出都只是在模块顶层出现，引入模块都是常量不能动态设置inport的内容，引入模块是不能去修改的，这点就和require不同，treeshaking利用es6特性主要是对模块代码静态分析，因此编译阶段判断代码是否用到就要确定下来，判断没用到代码会增加注释标记，在uglify阶段去删除无用代码。")]),s._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[s._v("项目搭建，我们对webpack的诉求是：\n\njs的处理：转换 "),a("span",{pre:!0,attrs:{class:"token constant"}},[s._v("ES6")]),s._v(" 代码，解决浏览器兼容问题"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("\ncss的处理：编译css，自动添加前缀，抽取css到独立文件"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("\nhtml的处理：复制并压缩html文件"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("\ndist的清理：打包前清理源目录文件"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("\nassets的处理：静态资源处理"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("\nserver的启用：development 模式下启动服务器并实时刷新"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("666")]),s._v("\n\n\n__dirname指的是nodejs的一个全局变量，指向当前执行脚本文件所在的目录路径，也是绝对路径\n\n")])])])])}),[],!1,null,null,null);t.default=n.exports}}]);